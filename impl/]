// Implementation of a lazy propagated segment tree
//
// 1-based indexing FTW
#include <iostream>
#include <cmath>
#include <vector>
using data_t = int;
typedef struct interval {
    size_t left, right;
    data_t data;
    interval(size_t l, size_t r, data_t d) {
        left = l;
        right = r;
        data = d;
    }
} interval;
size_t n;
std::vector<interval> tree;
// Combine info from two intervals
void combine(size_t left, size_t right, size_t parent);
void set_tree_size() {
    size_t size = 1 << ((size_t)log2(n) + 1);
    tree.assign(size, interval(0, 0, 0));
}
void init_tree(std::initializer_list<data_t> origin) {
    size_t i = 0;
    // First fill the leaves
    for (auto it = origin.begin(); it != origin.end(); it++) {
        tree[i + n] = interval(i + 1, i + 1, *it);
        i++;
    }
    // Fill the nodes which are left
    for (i = n + origin.size(); i < tree.size(); i++) {
        tree[i] = interval(i + 1, i + 1, 0);
    }
    // Combine info to the parents
    for (i = n - 1; i >= 1; i--) {
        size_t left = i << 1;
        size_t right = left + 1;
        tree[i].left = left;
        tree[i].right = right;
        combine(left, right, i);
    }
}
void point_update(int i, data_t new_val) {
    size_t id = i + n - 1; // The index of the element in the segtree
    tree[id].data = new_val;
    // Go to parent
    id >>= 1;
    // Traverse the tree and issue updates
    while (id >= 1) {
        auto left = id << 1;
        auto right = left + 1;
        combine(left, right, id);
        id >>= 1;
    }
}
void range_query(int left, int right, interval ans) {}
void range_update() {}
int main() {
    // To implement a segment tree
}
