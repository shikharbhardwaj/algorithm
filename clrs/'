#include <cstdio>
#include <iostream>
#include <vector>
#include <cmath>
struct node{
    int  min, max, num, i; //Store the limits of the current node along with the value
    node(){
        num = max = min = 0;
    }
    node(int in,int im,int ip, int ctr){
        min = in;
        max = im;
        num = ip;
        i = ctr;
    }
};
class SegTree{
    private:
        std::vector<node> tree;
        int num;
    public: 
        SegTree(){
            tree.push_back({0,0,0,0});
        }
        SegTree(int n){ //The number of elements to be intervalized
            num = n;
            tree.push_back({0,0,0,0});    //First node unused
            int lastMax, lastMin, length;
            lastMax = n;
            lastMin = 1;
            length = n;
            int ctr = 1;
            for(int i = 1; i <= log2(n) + 1; i++){  //The height of the tree
                for(int j = 1; j <= pow(2,i-1); j++){
                    tree.push_back({lastMin, lastMax, 0, ctr});
                    lastMin += length;
                    lastMax += length;
                    ctr++;
                }
                length /= 2;
                lastMin = 1;
                lastMax = length;
            }
        }
        void toString(){
            std::cout<<std::endl;
            int ctr = 0;
            for(auto elem : tree){
                std::cout<<ctr<<" : ["<<elem.min<<", "<<elem.max<<"] num : "<<elem.num<<std::endl;
                ctr++;
            }
            std::cout<<std::endl;
        }
        inline void flip(node &ref){
            ref.num = abs(ref.num - ref.max + ref.min - 1);
            if(ref.i * 2 < tree.size() ){
                flip(tree[ref.i * 2]);
            }
            if(ref.i * 2 + 1 < tree.size()){
                flip(tree[ref.i * 2 + 1]);
            }
        }
        void flipInterval(int min, int max, node &cur){
            if(min == cur.min && max == cur.max){
                flip(cur);   //Perfect
            }
            else if(min == cur.min && max > cur.max){
                flip(cur);
                if(cur.i + 1 < tree.size()){    //Choose the right sibling
                    flipInterval(cur.max + 1, max, tree[cur.i + 1]);
                }
            }
            else if(min < cur.min && max == cur.max){ //This is a subset
                flip(cur);
                if(cur.i - 1 >= 1){
                    flipInterval(min, cur.min - 1, tree[cur.i - 1]);
                }
            }
            else if(min >= cur.min && max <= cur.max){
                if( cur.i * 2 < tree.size()){
                    flipInterval(min, max, tree[cur.i * 2]);
                }
                if(cur.i * 2 + 1 < tree.size()){
                    flipInterval(min, max, tree[cur.i * 2 + 1]);
                }
            }
        }
        int queryInterval(int min, int max, Node cur){
           if(min == cur.min && max == cur.max){
                return cur.num;
            }
            else if(min == cur.min && max > cur.max){
                flip(cur);
                if(cur.i + 1 < tree.size()){    //Choose the right sibling
                    flipInterval(cur.max + 1, max, tree[cur.i + 1]);
                }
            }
            else if(min < cur.min && max == cur.max){ //This is a subset
                flip(cur);
                if(cur.i - 1 >= 1){
                    flipInterval(min, cur.min - 1, tree[cur.i - 1]);
                }
            }
            else if(min >= cur.min && max <= cur.max){
                if( cur.i * 2 < tree.size()){
                    flipInterval(min, max, tree[cur.i * 2]);
                }
                if(cur.i * 2 + 1 < tree.size()){
                    flipInterval(min, max, tree[cur.i * 2 + 1]);
                }
            } 
        }
        node& root(){
            if(tree.size() > 1){
                return tree[1];

            }
            return tree[0];
        }
        node &lastParent(){
            return tree[(tree.size() - 1)/2];
        }
        void rebuild(node &cur){
            if(cur.i * 2 < tree.size()){
                cur.num = tree[cur.i * 2].num;
            }
            if(cur.i * 2 + 1 < tree.size()){
                cur.num += tree[cur.i * 2 + 1].num;
            }
            if(cur.i - 1 >= 1){
                rebuild(tree[cur.i - 1]);
            }
        }
};
int main(){
    SegTree s1(16);
    s1.flipInterval(1,6, s1.root());
    s1.rebuild(s1.lastParent());
    s1.toString();
    std::cin.get();
    s1.flipInterval(1,6, s1.root());
    s1.rebuild(s1.lastParent());
    s1.toString();
    return 0;
}
